

----QUIT----2020-01-22T20:54:30.239682+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!

----QUIT----2020-01-22T20:54:52.539489+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!
!BaselineOfLogicBoolean commentStamp: '' prior: 0!
I represent the software configuration of the Logic-Boolean package.

Metacello uses me to download & install Logic-Boolean and its dependencies.  For example:

```Smalltalk
Metacello new
	repository: 'github://octotrike/trike/src';
	baseline: 'LogicBoolean';
	load
```

I'm a very simple subclass of BaselineOf.  The best resource for understanding my use and API is the [Baselines](https://github.com/pharo-open-documentation/pharo-wiki/blob/master/General/Baselines.md) documentation on the Pharo wiki.
!
!BaselineOfLogicBoolean methodsFor: 'baselines' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
baseline: spec
    <baseline>

    spec for: #common do: [
        spec
            package: 'Logic-Boolean';
				package: 'Logic-Boolean-Tests' with: [ spec requires: #('Logic-Boolean') ]].
! !

"BaselineOfLogicBoolean"!
!BLFunctionPresenter commentStamp: 'BrenLarcom 2/11/2020 16:16' prior: 0!
I am a composable presenter that displays Boolean functions as trees.

I create presenters and connect them to the Boolean function(s) I present and
each other.

## Public API

### Instantiation

```Smalltalk
(self on: (BLVariable named: 'A' equals: 'the moon is made of green cheese'))
	openWithSpec.
```

See also BLFunctionPresenterTest>>testModelVariable.

## Internals

### Instance Variables

tree: <SpTreeTablePresenter> - A tree view of the varable names in the
	expression(s) I present, and the corresponding atoms.
!
!BLVariable commentStamp: 'BrenLarcom 2/5/2020 19:15' prior: 0!
Instances of me represent variables in Boolean logic.

I allow arbitrary objects to be included in Boolean functions.

## Public API

### Instantiation

```Smalltalk
self on: 'the moon is made of green cheese'.
self named: 11 equals: [ DateAndTime now hour > 12 ].
self named: 'C'.
```

See also the examples protocol on my class side.

## Internals

### Instance Variables

atom (optional): <Object> - An object (e.g. a <Boolean>, <String>, or
	<BlockClosure>) that represents the value of this variable.  Only nil,
	true, false, and blocks with no arguments are meaningful to this library;
	the application must interpret any other values.

name (optional): <Object> - An identifier (e.g. a <String> or <Number>) for this
	variable.

At least one of name or atom should be specified.
!
!BLFunctionPresenter class methodsFor: 'commands' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
buildCommandsGroupWith: presenter forRoot: rootCommandGroup
	"Attach commands appropriate for the current presenter context to rootCommandGroup"

	rootCommandGroup 
		register: (self buildContextMenuCommandsGroupWith: presenter).
! !
!BLFunctionPresenter class methodsFor: 'commands' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
buildContextMenuCommandsGroupWith: presenter
	"Answer a group of commands that should be displayed in a context menu on my model."
	
	^ (CmCommandGroup named: self contextMenuCommandsGroupID) asSpecGroup
			register: (self buildItemCommandsGroupWith: presenter);
			yourself! !
!BLFunctionPresenter class methodsFor: 'commands' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
buildItemCommandsGroupWith: presenter
	"Answer a group of commands that apply to the currently selected item."
	
	^ (CmCommandGroup named: self itemCommandsGroupID) asSpecGroup
			description: ('Commands that affect the selected item.' flag: #i18n);
			register: BLEditVariable forSpec;
			register: BLToggleNegated forSpec;
			beDisplayedAsGroup;
			yourself! !
!BLFunctionPresenter class methodsFor: 'commands' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
contextMenuCommandsGroupID
	"Answer an identifier for a group of commands to use as a context menu for this presenter."

	^ 'Context Menu' flag: #i18n; flag: #todo 
	"Does this really need to be i18n?  Or is it an identifier for developers?"
! !
!BLFunctionPresenter class methodsFor: 'specs' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
defaultSpec
	"Answer a default layout for instances of me."
	<spec>
			
	^SpBoxLayout newHorizontal
		add: #tree;
		yourself
! !
!BLFunctionPresenter class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
instanceWithAtom
	<sampleInstance>

	^ self on: BLVariable instanceWithAtom ! !
!BLFunctionPresenter class methodsFor: 'commands' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
itemCommandsGroupID
	"Answer an identifier for a group of commands that apply to the currently selected item."

	^ 'Selected Item' flag: #i18n; flag: #todo 
	"Does this really need to be i18n?  Or is it an identifier for developers?"
! !
!BLFunctionPresenter class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
namedInstance
	<sampleInstance>

	^ self on: BLVariable namedInstance ! !
!BLFunctionPresenter class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
namedInstanceWithAtom
	<sampleInstance>

	^ self on: BLVariable namedInstanceWithAtom ! !
!BLFunctionPresenter class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
negatedInstanceWithAtom
	<sampleInstance>

	^ self on: BLVariable negatedInstanceWithAtom! !
!BLFunctionPresenter class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
negatedNamedInstance
	<sampleInstance>

	^ self on: BLVariable negatedNamedInstance! !
!BLFunctionPresenter class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
negatedNamedInstanceWithAtom
	<sampleInstance>

	^ self on: BLVariable negatedNamedInstanceWithAtom! !
!BLFunctionPresenter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
aboutText
	"Answer a title string for my window, if I am displayed on my own."

	^ 'I represent a variable in a Boolean logic expression.'

! !
!BLFunctionPresenter methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
hasSelectedItem
	^ self selectedItem notNil
! !
!BLFunctionPresenter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
initializePresenters
	"Create & configure presenters to view my model."

	"Instantiate widgets"
	tree := self newTreeTable.
	
	"Configure widgets"
	tree
		addColumn: (SpStringTableColumn
			title: ('Expression' flag: #i18n)
			evaluated: #displayString);
		contextMenuFromCommandsGroup: [ self rootCommandsGroup / 'Context Menu' ];
		children: [ :anObject | #() ];
		beResizable.
	
	"Specify focus order"
	self focusOrder add: tree
! !
!BLFunctionPresenter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
initializeWindow: aWindowPresenter
	"Set window values when I am displayed on my own."

	aWindowPresenter
		title: self windowTitle;
		aboutText: self aboutText
! !
!BLFunctionPresenter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
model: aBLVariable
	"Update my model and notify my subscribers."

	super model: aBLVariable.
	self modelChanged
! !
!BLFunctionPresenter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
modelChanged
	"My model (announcingObject) has changed"

	super modelChanged.
	self tree roots: { announcingObject }! !
!BLFunctionPresenter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
selectedItem
	^ self tree selection selectedItem! !
!BLFunctionPresenter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
title
	"Answer a title for my window, if I am displayed on my own"
	"This method has different semantics from the one Spec is deprecating."	

	^ self announcingObject class name
! !
!BLFunctionPresenter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
tree
	^ tree! !
!BLFunctionPresenter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
windowTitle
	"Answer a title string for my window, if I am displayed on my own."

	^ self announcingObject class name
! !
!BLCommand class methodsFor: 'user interaction' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
defaultDescription
	"Answer a short description of what my instances do when executed"
	"What does this do?  Why would I want to do that?
	"
	"This description should be:
		- in English
		- in the [imperative mood](https://en.wikipedia.org/wiki/Imperative_mood)
		- without a period
		- capitalized like a sentence
		- represented as a String (or String-equivalent)

	The implied receiver of the verb clause is a BLExpression the user selects
	using this instance's context/presenter.
	
	Good examples of sentences in this style, from the Pharo toolbar menus:
		- Browse test class
		- Generate accessors
		- Copy

	Examples of entries in the class context menu that are not in this style:
		- Class refs.
		- New trait"

	^ self subclassResponsibility
! !
!BLCommand class methodsFor: 'user interaction' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
defaultName
	"Answer a short name for what my instances do when executed"
	"This name should be:
		- in English
		- a verb clause
		- in the [imperative mood](https://en.wikipedia.org/wiki/Imperative_mood)
		- without a period
		- capitalized like a sentence
		- represented as a String (or String-equivalent)

	The implied receiver of the verb clause is a BLExpression the user selects
	using this instance's context/presenter.
	
	Good examples of verb clauses in this style, from the class context menu
	in the system browser:
		- Browse test class
		- Generate accessors
		- Copy

	Examples of entries in the class context menu that are not in this style:
		- Class refs.
		- New trait"

	^ self subclassResponsibility
! !
!BLCommand methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
expression
	"Shortcut to get expression I manipulate"

	^ self presenter selectedItem
! !
!BLCommand methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
hasExpression

	^ self presenter hasSelectedItem
! !
!BLCommand methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
presenter
	"Shortcut to get presenter that is presenting my expression"

	^ self context
! !
!BLEditVariable class methodsFor: 'user interaction' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
defaultDescription
	^ 'Update the name and value of the selected variable.' flag: #i18n
! !
!BLEditVariable class methodsFor: 'user interaction' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
defaultName
	^ 'Edit' flag: #i18n
! !
!BLEditVariable methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
canBeExecuted
	^ self hasExpression
! !
!BLEditVariable methodsFor: 'executing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
execute
	self expression edit
! !
!BLToggleNegated class methodsFor: 'user interaction' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
defaultDescription
	"Answer a short English sentence about the effect of executing my instances"

	^ 'Change whether the selected variable is negated.' flag: #i18n
! !
!BLToggleNegated class methodsFor: 'user interaction' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
defaultName
	"Answer a short name for what my instances do when executed"

	^ 'Toggle negated' flag: #i18n
! !
!BLToggleNegated methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
canBeExecuted
	^ self hasExpression
! !
!BLToggleNegated methodsFor: 'executing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
execute
	self expression toggleNegated
! !
!BLVariable class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
instanceWithAtom
	"Answer an instance of me that has an atom, but no name"
	"See https://en.wikipedia.org/wiki/Liar_paradox"
	<sampleInstance>

	^ self on: ('this sentence is false' flag: #i18n)
! !
!BLVariable class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
named: anObject
	"Answer a new instance of myself, with anObject as its name."

	^ self new
		name: anObject;
		yourself
! !
!BLVariable class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
named: anIdentifyingObject equals: aValueObject
	"Answer a new instance of myself, with anIdentifyingObject as its name and
	 anObject as its atom."

	^ self new
		name: anIdentifyingObject;
		atom: aValueObject;
		yourself
! !
!BLVariable class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
namedInstance
	"Answer an instance of me that has a name, but no atom"
	<sampleInstance>

	^ self named: 'x'
! !
!BLVariable class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
namedInstanceWithAtom
	"Answer an instance of me that has both a name and an atom"
	"See https://www.urbandictionary.com/define.php?term=there%27s%20no%20there%20there"
	<sampleInstance>

	^ self named: 'y' equals: ('there''s no there there' flag: #i18n)
! !
!BLVariable class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
negatedInstanceWithAtom
	"Answer a negated instance of me with an atom, but no name"
	<sampleInstance>

	^ self instanceWithAtom negated
! !
!BLVariable class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
negatedNamedInstance
	"Answer a negated instance of me with a name, but no atom"
	<sampleInstance>

	^ self namedInstance negated
! !
!BLVariable class methodsFor: 'examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
negatedNamedInstanceWithAtom
	"Answer a negated instance of me with both a name and an atom"
	<sampleInstance>

	^ self namedInstanceWithAtom negated
! !
!BLVariable class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
on: anObject
	"Answer a new instance of myself, with anObject as its atom."

	^ self new
		atom: anObject;
		yourself
! !
!BLVariable methodsFor: 'comparing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
= anObject
	"Answer whether I am equivalent to anObject."

	^ self class = anObject class
		and: [(self atom = anObject atom)
		and: [self isNegated = anObject isNegated]]
! !
!BLVariable methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
asPositive
	"Answer a (possibly new) similar instance of my class, with a positive sense."

	^ self isNegated ifTrue: [ self negated ] ifFalse: [ self ]
! !
!BLVariable methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
atom
	^ atom
! !
!BLVariable methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
atom: anObject
	atom := anObject
! !
!BLVariable methodsFor: 'comparing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
hash
	^ (atom hash
			bitXor: name hash)
			bitXor: (not ifTrue: [255] ifFalse: [0])
! !
!BLVariable methodsFor: 'initialization' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
initialize
	"Set my initial state."
	super initialize.
	not := false
! !
!BLVariable methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
isNegated
	"Answer whether my sense is inverted."
	^ not
! !
!BLVariable methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
isNegated: aBoolean
	"Set whether my sense is inverted."
	not := aBoolean.
	self valueChanged
! !
!BLVariable methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
name
	^ name
! !
!BLVariable methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
name: anObject
	"Change my identifier"
	"This variable name is what represents me when a BLExpression is shown as a
	 function.  Usually anObject is a String, but it could be a Character, a
	Number, some application-specific object, or whatever else the caller wants."

	name := anObject.
	self halt.
	self update
! !
!BLVariable methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
negated
	"Answer a new instance of my class, with the opposite meaning."
	^ (self copy) toggleNegated; yourself
! !
!BLVariable methodsFor: 'printing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
printOn: aStream
	"Print my details."

	not ifTrue: [ aStream nextPutAll: ('NOT ' flag: #i18n) ].
	name ifNotNil: [
		name printOn: aStream.
		atom ifNotNil: [ aStream nextPutAll: ': ' ]].
	atom ifNotNil: [ atom printOn: aStream ].
	(name isNil and: [ atom isNil ])
		ifTrue: [ super printOn: aStream ]
! !
!BLVariable methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
simplified
	"Answer a simplified version of myself."
	
	^self
! !
!BLVariable methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
toggleNegated
	"Toggle whether my sense is inverted."
	self
		isNegated: (not
				ifTrue: [false]
				ifFalse: [true])
! !
!BLVariable methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
value
	"Answer the result of evaluating me."
	"This will throw MessageNotUnderstood when atom does not evaluate to a Boolean."

	^ self isNegated
		ifFalse: [ atom value ]
		ifTrue: [ 
			atom
				ifNotNil: [ atom value not ]
				ifNil: [ nil ]
		]
! !

"Logic-Boolean"!
!BLCommandTest commentStamp: '<historical>' prior: 0!
A BLCommandTest is a test class for testing the behavior of BLCommand!
!BLToggleNegatedTest commentStamp: '<historical>' prior: 0!
A BLToggleNegatedTest is a test class for testing the behavior of BLToggleNegated!
!BLFunctionPresenterTest commentStamp: 'BrenLarcom 2/5/2020 14:45' prior: 0!
I test BLFunctionPresenter.!
!BLVariableTest commentStamp: '' prior: 0!
I test BLVariable.
!
!BLCommandTest class methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
isAbstract
	"I am abstract, but my subclasses are not"

	^self name = #BLCommandTest 
			! !
!BLCommandTest class methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
mustTestCoverage

	^ true! !
!BLCommandTest methodsFor: 'running' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
setUp
	"Instantiate a command for test use"

	super setUp.
	command := self classToBeTested new
! !
!BLCommandTest methodsFor: 'tests - accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testPresenter
	"Confirm the presenter shortcut works"

	"We don't specify a context in setUp, so presenter should start out as nil."
	self assert: command presenter equals: nil.

	"After we specify a context, our presenter should be a presenter."
	command asSpecCommand.
	self flag: #todo.  "How do we specify a context?"
	self assert: command presenter isPresenter
	
	! !
!BLToggleNegatedTest methodsFor: 'coverage' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
classToBeTested
	
	^ BLToggleNegated ! !
!BLFunctionPresenterTest class methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
mustTestCoverage
	^ true! !
!BLFunctionPresenterTest methodsFor: 'coverage' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
classToBeTested
	
	^ BLFunctionPresenter! !
!BLFunctionPresenterTest methodsFor: 'coverage' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
selectorsToBeIgnored
	| testedInSetUp calledByTestedMethods |

	testedInSetUp := #( #defaultSpec #initializePresenters ).
	calledByTestedMethods := #( #initializeWindow: #modelChanged ).

	^ super selectorsToBeIgnored, testedInSetUp, calledByTestedMethods! !
!BLFunctionPresenterTest methodsFor: 'running' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
setUp
	"Prepare my test fixture.  Run before each test* method."

	super setUp.

	presenter := self classToBeTested new
! !
!BLFunctionPresenterTest methodsFor: 'running' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
tearDown
	"Clean my fixture before the next test"
	| window |

	window := presenter owner. 
	window ifNotNil: [ window close ].

	super tearDown! !
!BLFunctionPresenterTest methodsFor: 'tests - displaying' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testAboutText
	"Confirm my presenter passes its aboutText to its owner."

	presenter openWithSpec.

	self assert: presenter window aboutText equals: presenter aboutText
! !
!BLFunctionPresenterTest methodsFor: 'tests - displaying' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testContextMenu

	"Confirm that there is a context menu."
	self assert: [ presenter tree contextMenu value isMenuPresenter ]

	"We're testing whether the contextMenu has the correct entries when we test
	 each individual command.  See tests - execution."

! !
!BLFunctionPresenterTest methodsFor: 'tests - execution' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testEditVariable

	self flag: #todo
! !
!BLFunctionPresenterTest methodsFor: 'tests - examples' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testExamples 
	"Confirm that no examples throw exceptions"

  self classToBeTested instanceWithAtom openWithSpec close.
	self classToBeTested namedInstance openWithSpec close.
	self classToBeTested namedInstanceWithAtom openWithSpec close.
	self classToBeTested negatedInstanceWithAtom openWithSpec close.
	self classToBeTested negatedNamedInstance openWithSpec close.
	self classToBeTested negatedNamedInstanceWithAtom openWithSpec close

! !
!BLFunctionPresenterTest methodsFor: 'tests - navigation' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testFocusOrder
	"Confirm my presenter has a focus order that includes all the subpresenters."

	presenter openWithSpec.

	self assert: presenter focusOrder equals: presenter presenters ! !
!BLFunctionPresenterTest methodsFor: 'tests - displaying' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testHasTreeWidget
	"Confirm my target contains a tree widget"

	presenter openWithSpec.
	self assert: (presenter owner hasPresenter: presenter tree)
! !
!BLFunctionPresenterTest methodsFor: 'tests - updating' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testModelChanged
	"Confirm that changing a presenter's model changes its tree's model."
	| namedInstance instanceWithAtom |

	namedInstance := BLVariable namedInstance.
	presenter model: namedInstance.
	self assert: [ presenter tree roots includes: namedInstance ].

	instanceWithAtom := BLVariable instanceWithAtom.
	presenter model: instanceWithAtom.
	self assert: [ presenter tree roots includes: instanceWithAtom ].
	self deny: [ presenter tree roots includes: namedInstance ]

! !
!BLFunctionPresenterTest methodsFor: 'tests - displaying' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testModelVariable
	"Test my target's display of different kinds of Boolean variables"
			
	| instanceWithAtom namedInstance namedInstanceWithAtom |
	
	instanceWithAtom := self classToBeTested new
		model: BLVariable instanceWithAtom;
		openWithSpec.
	self assert: instanceWithAtom isDisplayed.
	instanceWithAtom close.
	self deny: instanceWithAtom isDisplayed.

	namedInstance := self classToBeTested new
		model: BLVariable namedInstance;
		openWithSpec.
	self assert: namedInstance isDisplayed.
	namedInstance close.
	self deny: namedInstance isDisplayed.

	namedInstanceWithAtom := self classToBeTested new
		model: BLVariable namedInstanceWithAtom;
		openWithSpec.
	self assert: namedInstanceWithAtom isDisplayed.
	namedInstanceWithAtom close.
	self deny: namedInstanceWithAtom isDisplayed
! !
!BLFunctionPresenterTest methodsFor: 'tests - updating' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testNameValueChanged
	"Confirm that changing a presenter's model changes its tree's model."
	| variable newName dataSource |

	variable := BLVariable negatedNamedInstanceWithAtom.
	presenter model: variable.
	presenter openWithSpec.
	dataSource := presenter tree adapter widget dataSource.

	self assert: [ "dataSource rootItem children."
		"childrenFor: variable?"
		"name is showing in presenter" true ].

	newName := 'I changed your name'.
	self halt.
	variable name: newName. 
	dataSource updateData.
	self assert: [ "newName is showing in presenter"
		"tree needs to receive update" ]! !
!BLFunctionPresenterTest methodsFor: 'tests - displaying' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testOpen
	"Confirm my target can be opened in this test environment"

	"No need for an assertion to test whether creating an instance throws an
	 Exception; the test will already be marked as an error if it throws an
	 Exception while creating an instance during #setUp."

	"Likewise, no need for an assertion to test whether opening a presenter
	 throws an exception."
	presenter openWithSpec.
	self assert: presenter isDisplayed.
	
	presenter owner close.
	self deny: presenter isDisplayed
! !
!BLFunctionPresenterTest methodsFor: 'tests - updating' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testSelectedItem
	"Confirm that selecting an item changing a presenter's model changes its tree's model"
	
	"By default, no item is selected."
	self deny: presenter hasSelectedItem.
	self assert: presenter selectedItem equals: nil.

	"Selecting an item means that item is the selectedItem."
	"See SpTreeTablePresenterTest and the simulation protocol of SpTreeTablePresenter."
	self flag: #todo.
	
	"After deselecting everything, no item is selected."
	presenter tree unselectAll.
	self deny: presenter hasSelectedItem.
	self assert: presenter selectedItem equals: nil
! !
!BLFunctionPresenterTest methodsFor: 'tests - displaying' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testTitle
	"Confirm my presenter has the correct title"

	presenter openWithSpec.

	self assert: presenter title equals: nil class name
! !
!BLFunctionPresenterTest methodsFor: 'tests - displaying' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testToggleNegatedMenuItem
	"Test whether toggleNegated is present or greyed out in the right situations"
  | menuPresenter toggleNegatedCommand window |

	"toggleNegated appears on the menu."
	menuPresenter := presenter rootCommandsGroup asMenuPresenter.
  window := menuPresenter openWithSpec.
	toggleNegatedCommand :=
			(presenter rootCommandsGroup allCommands select: [ :each |
				each name = BLToggleNegated defaultName ]) anyOne.
	self assert: toggleNegatedCommand notNil.
	"entries includes One named BLToggleNegated defaultName"
	"presenter tree contextMenu value menuGroups menuItems"

	"By default, no item is selected.  Therefore toggleNegated is greyed out on
	 the menu."
	self deny: presenter hasSelectedItem.
	self deny: toggleNegatedCommand canBeExecuted.


"Should not appear when an item is not selected."
	"Selecting an item means that toggleNegated is available to "
	"See SpTreeTablePresenterTest and the simulation protocol of
	 SpTreeTablePresenter."
	self flag: #todo.
	
	"After deselecting everything, no item is selected, and therefore
	 toggleNegated should be greyed out."
	presenter tree unselectAll.
	self deny: presenter hasSelectedItem.
	self should: [ presenter rootCommandsGroup commandOrGroupNamed: 'Selected Item' ] 
		raise: NotFound.

	window close
! !
!BLFunctionPresenterTest methodsFor: 'tests - displaying' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testTreeTitle
	"Confirm the first column of my tree widget has the correct title"

	presenter openWithSpec.

	self assert: presenter tree columns first title equals: ('Expression' flag: #i18n)
! !
!BLFunctionPresenterTest methodsFor: 'tests - displaying' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testWindowTitle
	"Confirm my presenter passes a windowTitle to its owner when opened standalone."

	presenter openWithSpec.

	self assert: presenter window title equals: presenter windowTitle

! !
!BLVariableTest class methodsFor: 'testing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
mustTestCoverage
	^ true
! !
!BLVariableTest methodsFor: 'coverage' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
classToBeTested
	
	^ BLVariable! !
!BLVariableTest methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
nameForB
	^ 11
! !
!BLVariableTest methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
nameForC
	^ 'C'
! !
!BLVariableTest methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
objectForA
	"See https://en.wikipedia.org/wiki/The_Moon_is_made_of_green_cheese"

	^ 'the moon is made of green cheese' flag: #i18n
! !
!BLVariableTest methodsFor: 'accessing' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
objectForB
	^ [ false ]
! !
!BLVariableTest methodsFor: 'coverage' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
selectorsToBeIgnored
	| testedInSetUp calledByTestedMethods |

	testedInSetUp := #( #named: #named:equals: #on: ).
	calledByTestedMethods := #( #= #initialize #printOn: ).

	^ super selectorsToBeIgnored, testedInSetUp, calledByTestedMethods
! !
!BLVariableTest methodsFor: 'running' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
setUp
	"Prepare my test fixture.  Run before each test* method."

	super setUp.

	a := self classToBeTested on: self objectForA.
	b := self classToBeTested named: self nameForB equals: self objectForB.
	c := self classToBeTested named: self nameForC.! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testAsPositive
	"Test creation of a positive instance (non-negated)"

	self deny: [ a asPositive isNegated ].
	self deny: [ a negated asPositive isNegated ].

	self deny: [ b asPositive isNegated ].
	self deny: [ b negated asPositive isNegated ].
	
	self deny: [ c asPositive isNegated ].
	self deny: [ c negated asPositive isNegated ]
! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testAtom
	"Change the atom of an instance"

	"Change an existing atom."
	a atom: self objectForB.
	"BlockClosure does not include an equivalence test."
	self assert: a atom printString equals: self objectForB printString.

	"Unset an existing atom."
	a atom: nil.
	self assert: a atom equals: nil.

	"Set a previously unset atom."
	c atom: self objectForA.
	self assert: c atom equals: self objectForA.
! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testEquals
	"Compare instances"
	| notA |

	self assert: a equals: a.
	self deny: a equals: b.

	self assert: b equals: b.

	self assert: c equals: c.

	notA := a negated.
	self deny: a equals: notA
! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testExamples
	"Create specific instances of the class I test"
	| atomOnly nameOnly both |

	atomOnly := self classToBeTested instanceWithAtom.
	self
		deny:   [ atomOnly atom isNil ];
		assert: [ atomOnly name isNil ].

	nameOnly := self classToBeTested namedInstance.
	self
		assert: [ nameOnly atom isNil ];
		deny:   [ nameOnly name isNil ].

	both := self classToBeTested namedInstanceWithAtom.
	self
		deny:   [ both atom isNil ];
		deny:   [ both name isNil ]
! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testHash
	"Hash an instance (non-cryptographically)"
	| notA notB notC |

	self assert: a hash equals: a hash.
	self assert: b hash equals: b hash.
	self assert: c hash equals: c hash.

	notA := a negated.
	notB := b negated.
	notC := c negated.
	self deny: a hash equals: notA hash.
	self deny: b hash equals: notB hash.
	self deny: c hash equals: notC hash.

	self assert: notA hash equals: notA hash.
	self assert: notB hash equals: notB hash.
	self assert: notC hash equals: notC hash.

	self deny: a hash equals: b hash.
	c name: self nameForB.
	self deny: b hash equals: c hash.
	b atom: self objectForA.
	self deny: a hash equals: b hash.


! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testInstanceCreation
	"Create an instance of the class I test"

	"No need for an assertion to test whether creating an instance throws an
	 Exception; the test will already be marked as an error if it throws an
	 Exception while creating an instance during #setUp."

	"The variable's name & atom (value) should be passed through unchanged."
	self assert: a name equals: nil.
	self assert: a atom equals: self objectForA.

	self assert: b name equals: self nameForB.
	"BlockClosure does not include an equivalence test."
	self assert: b atom printString equals: self objectForB printString.

	self assert: c name equals: self nameForC.
	self assert: c atom equals: nil.
! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testIsNegated
	"Test accessors for not instance variable"

	self deny: [ a isNegated ].
	a isNegated: true.
	self assert: [ a isNegated ].
	a isNegated: false.
	self deny: [ a isNegated ].

	self deny: [ b isNegated ].
	b isNegated: false.
	self deny: [ b isNegated ]

! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testName	
	"Change the name of an instance"

	"Set a previously unset name."
	a name: self nameForB.
	self assert: a name equals: self nameForB.

	"Change an existing name."
	b name: self nameForC.
	self assert: b name equals: self nameForC.

	"Unset an existing name."
	c name: nil.
	self assert: c name equals: nil.


! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testNegativeExamples
	"Create specific instances of the class I test"
	| atomOnly nameOnly both |

	atomOnly := self classToBeTested negatedInstanceWithAtom.
	self
		deny:   atomOnly atom isNil;
		assert: atomOnly name isNil;
		assert: atomOnly isNegated.

	nameOnly := self classToBeTested negatedNamedInstance.
	self
		assert: nameOnly atom isNil;
		deny:   nameOnly name isNil;
		assert: nameOnly isNegated.

	both := self classToBeTested negatedNamedInstanceWithAtom.
	self
		deny:   both atom isNil;
		deny:   both name isNil;
		assert: both isNegated
! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testPositiveExamples
	"Create specific instances of the class I test"
	| atomOnly nameOnly both |

	atomOnly := self classToBeTested instanceWithAtom.
	self
		deny:   atomOnly atom isNil;
		assert: atomOnly name isNil;
		deny:   atomOnly isNegated.

	nameOnly := self classToBeTested namedInstance.
	self
		assert: nameOnly atom isNil;
		deny:   nameOnly name isNil;
		deny:   nameOnly isNegated.

	both := self classToBeTested namedInstanceWithAtom.
	self
		deny:   both atom isNil;
		deny:   both name isNil;
		deny:   both isNegated
! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testPrintOn
	"Print an instance, thereby testing printOn:"
	| negationPhrase uninit |

	negationPhrase := 'NOT' flag: #i18n.

	"Uninitialized instance"
	uninit := self classToBeTested new.
	self
		assert: [ uninit printString includesSubstring: self classToBeTested name ];
		deny:   [ uninit printString includesSubstring: ': ' ];
		assert: [ uninit negated printString includesSubstring: negationPhrase ].

	"Atom only"
	self
		assert: [ a printString includesSubstring: self objectForA printString ];
		deny:   [ a printString includesSubstring: ': ' ];
		assert: [ a negated printString includesSubstring: negationPhrase ].

	"Name only"
	self
		assert: [ c printString includesSubstring: self nameForC printString ];
		deny:   [ c printString includesSubstring: ': ' ];
		assert: [ c negated printString includesSubstring: negationPhrase ].

	"Both"
	self
		assert: [ b printString includesSubstring: self nameForB printString ];
		assert: [ b printString includesSubstring: self objectForB printString ];
		assert: [ b printString includesSubstring: ': ' ];
		assert: [ b negated printString includesSubstring: negationPhrase ]

! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testSimplified
	"Simplify instances"

	self assert: a simplified equals: a.
! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testToggleNegated
	"Test accessors for not instance variable"

	self deny: [ c isNegated ].
	c toggleNegated.
	self assert: [ c isNegated ].
	c toggleNegated.
	self deny: [ c isNegated ]
! !
!BLVariableTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/6/2020 09:34:58'!
testValue
	"Test evaluation"
	"See https://en.wiktionary.org/wiki/actions_speak_louder_than_words"	
	| idiom |

	idiom := 'actions speak louder than words' flag: #i18n.

	self
		assert: a value equals: self objectForA;
		assert: b value equals: self objectForB value;
		assert: c value equals: nil;
		assert: (self classToBeTested on: true) value equals: true;
		assert: (self classToBeTested on: false) value equals: false;
		assert: (self classToBeTested on: [ true ]) value equals: true;
		assert: (self classToBeTested on: [ idiom ]) value equals: idiom;

		should: [ a negated value ] raise: MessageNotUnderstood;
		deny:   b negated value equals: self objectForB value;
		assert: c negated value equals: nil;
		assert: (self classToBeTested on: true) negated value equals: false;
		assert: (self classToBeTested on: false) negated value equals: true;
		assert: (self classToBeTested on: [ true ]) negated value equals: false;
		should: [ (self classToBeTested on: [ idiom ]) negated value ] raise: MessageNotUnderstood
! !

"Logic-Boolean-Tests"!
!BLVariable methodsFor: 'accessing' stamp: 'BrenLarcom 3/6/2020 14:10' prior: 33569797!
name: anObject
	"Change my identifier"
	"This variable name is what represents me when a BLExpression is shown as a
	 function.  Usually anObject is a String, but it could be a Character, a
	Number, some application-specific object, or whatever else the caller wants."

	name := anObject.
	self update
! !
!BLVariable methodsFor: 'accessing' stamp: 'BrenLarcom 3/6/2020 14:21' prior: 33591247!
name: anObject
	"Change my identifier"
	"This variable name is what represents me when a BLExpression is shown as a
	 function.  Usually anObject is a String, but it could be a Character, a
	Number, some application-specific object, or whatever else the caller wants."

	name := anObject.
	self valueChanged
! !
!FTBasicItem methodsFor: 'printing' stamp: 'BrenLarcom 3/6/2020 14:26' prior: 25361556!
printOn: aStream
	super printOn: aStream.
	aStream
		nextPut: $[;
		nextPutAll: (self dataSource toString: self);
		nextPut: $]! !

Smalltalk globals removeClassNamed: #AnObsoleteFont!
!FTBasicItemTest commentStamp: '<historical>' prior: 0!
A FTBasicItemTest is a test class for testing the behavior of FTBasicItem!

Smalltalk globals removeClassNamed: #AnObsoleteFTBasicItemTest!

----SNAPSHOT----2020-03-06T14:40:29.066044-06:00 2020-03-06.image priorSource: 100!

Smalltalk globals removeClassNamed: #AnObsoleteFont!

Smalltalk globals removeClassNamed: #AnObsoleteFont!
!BLFunctionPresenterTest methodsFor: 'tests - updating' stamp: 'BrenLarcom 3/6/2020 15:07' prior: 33577514!
testNameValueChanged
	"Confirm that changing a presenter's model changes its tree's model."
	| variable oldName newName dataSource |

	variable := BLVariable negatedNamedInstanceWithAtom.
	oldName := variable name.
	presenter model: variable.
	presenter openWithSpec.
	dataSource := presenter tree adapter widget dataSource.

	self assert: [ self halt "dataSource rootItem children."
		"childrenFor: variable?"
		"name is showing in presenter" ].

	newName := 'Z'.
	variable name: newName.
	self assert: [ "newName is showing in presenter" ]! !
!BLFunctionPresenterTest methodsFor: 'tests - updating' stamp: 'BrenLarcom 3/6/2020 15:07' prior: 33592723!
testNameValueChanged
	"Confirm that changing a presenter's model changes its tree's model."
	| variable oldName newName dataSource |

	variable := BLVariable negatedNamedInstanceWithAtom.
	oldName := variable name.
	presenter model: variable.
	presenter openWithSpec.
	dataSource := presenter tree adapter widget dataSource.

	self assert: [ self halt "dataSource rootItem children."
		"childrenFor: variable?"
		"oldName is showing in presenter" ].

	newName := 'Z'.
	variable name: newName.
	self assert: [ "newName is showing in presenter" ]! !
!BLFunctionPresenterTest methodsFor: 'tests - updating' stamp: 'BrenLarcom 3/6/2020 15:16' prior: 33593376!
testNameValueChanged
	"Confirm that changing a presenter's model changes its tree's model."
	| variable oldName newName dataSource |

	variable := BLVariable negatedNamedInstanceWithAtom.
	oldName := variable name.
	presenter model: variable.
	presenter openWithSpec.
	"dataSource := presenter tree adapter widget dataSource."
"... widget submorphs anyOne submorphs second submorphs anyOne submorphs second contents"
	self assert: [ self halt "dataSource rootItem children."
		"childrenFor: variable?"
		"oldName is showing in presenter" ].

	newName := 'Z'.
	variable name: newName.
	self assert: [ "newName is showing in presenter" ]! !

----SNAPSHOT----2020-03-06T15:16:54.664584-06:00 2020-03-06.image priorSource: 37989!

----SNAPSHOT----2020-03-06T15:43:51.236587-06:00 2020-03-06.image priorSource: 40238!
!BLFunctionPresenterTest methodsFor: 'tests - updating' stamp: 'BrenLarcom 3/6/2020 15:45' prior: 33594032!
testNameValueChanged
	"Confirm that changing a BLVariable's name changes what is presented to the user."
	| variable oldName newName stringMorph |

	variable := BLVariable negatedNamedInstanceWithAtom.
	oldName := 'Old name 856'
	variable name: oldName.

	presenter model: variable.
	presenter openWithSpec.
	
	self flag: #todo.
	"This is NOT the right way to figure out what strng is actually showing in the
	 UI.  Suggestions that do not go beyond the adapter (in this test) are very
	 welcome."
	stringMorph := presenter tree adapter widget submorphs anyOne
		submorphs second submorphs anyOne submorphs second.
	self assert: [ stringMorph contents contains: oldName ].

	newName := 'New name 029'.
	variable name: newName.
	self deny: [ stringMorph contents contains: oldName ].
	self assert: [ stringMorph contents contains: newName ]
! !

----SNAPSHOT----2020-03-06T15:45:48.339509-06:00 2020-03-06.image priorSource: 40325!
!BLFunctionPresenterTest methodsFor: 'tests - updating' stamp: 'BrenLarcom 3/6/2020 15:47' prior: 33594953!
testNameValueChanged
	"Confirm that changing a BLVariable's name changes what is presented to the user."
	| variable oldName newName stringMorph |

	variable := BLVariable negatedNamedInstanceWithAtom.
	oldName := 'Old name 856'.
	variable name: oldName.

	presenter model: variable.
	presenter openWithSpec.
	
	self flag: #todo.
	"This is NOT the right way to figure out what strng is actually showing in the
	 UI.  Suggestions that do not go beyond the adapter (in this test) are very
	 welcome."
	stringMorph := presenter tree adapter widget submorphs anyOne
		submorphs second submorphs anyOne submorphs second.
	self assert: [ stringMorph contents contains: oldName ].

	newName := 'New name 029'.
	variable name: newName.
	self deny: [ stringMorph contents contains: oldName ].
	self assert: [ stringMorph contents contains: newName ]
! !
!BLFunctionPresenterTest methodsFor: 'tests - updating' stamp: 'BrenLarcom 3/6/2020 15:54' prior: 33595992!
testNameValueChanged
	"Confirm that changing a BLVariable's name changes what is presented to the user."
	| variable oldName newName stringMorph |

	variable := BLVariable negatedNamedInstanceWithAtom.
	oldName := 'Old name 856'.
	variable name: oldName.

	presenter model: variable.
	presenter openWithSpec.
	
	self flag: #todo.
	"This is NOT the right way to figure out what strng is actually showing in the
	 UI.  Suggestions that do not go beyond the adapter (in this test) are very
	 welcome."
	(Delay forSeconds: 1) wait "for Morphs to be created".
	stringMorph := presenter tree adapter widget submorphs anyOne
		submorphs second submorphs anyOne submorphs second.
	self assert: [ stringMorph contents contains: oldName ].

	newName := 'New name 029'.
	variable name: newName.
	self deny: [ stringMorph contents contains: oldName ].
	self assert: [ stringMorph contents contains: newName ]
! !